[{"title":"Vue2-0-【第四季】第3节-实例事件","date":"2020-03-20T10:46:46.000Z","path":"/posts/68775ecc/","text":"Vue2.0 【第四季】第3节 实例事件 第3节 实例事件实例事件就是在构造器外部写一个调用构造器内部的方法。这样写的好处是可以通过这种写法在构造器外部调用构造器内部的数据。 我们还是写一个点击按钮，持续加1的例子。 一、$on 在构造器外部添加事件1234app.$on('reduce',function(){ console.log('执行了reduce()'); this.num--;}); $on接收两个参数，第一个参数是调用时的事件名称，第二个参数是一个匿名方法。 如果按钮在作用域外部，可以利用$emit来执行。 1234//外部调用内部事件function reduce(){ app.$emit('reduce');} 全部代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;example03&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;example03&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {％raw％} {{num}} {％endraw％} &lt;p&gt;&lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;p&gt;&lt;button onclick=\"reduce()\"&gt;reduce&lt;/button&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ num:1 }, methods:{ add:function(){ this.num++; } } }); app.$on(\"reduce\",function(){ console.log(\"执行了reduce方法\"); this.num--; }) function reduce(){ app.$emit('reduce'); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 二、$once执行一次的事件12345app.$once('reduceOnce',function(){ console.log('只执行一次的方法'); this.num--;}); 全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;example03&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;example03&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {％raw％} {{num}} {％endraw％} &lt;p&gt;&lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;p&gt;&lt;button onclick=\"reduce()\"&gt;reduce&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onclick=\"reduceOnce()\"&gt;reduceOnce&lt;/button&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ num:1 }, methods:{ add:function(){ this.num++; } } }); app.$on(\"reduce\",function(){ console.log(\"执行了reduce方法\"); this.num--; }) app.$once('reduceOnce',function(){ console.log('只执行一次的方法'); this.num--; }); function reduce(){ app.$emit('reduce'); } function reduceOnce(){ app.$emit('reduceOnce'); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 三、$off关闭事件···//关闭事件function off(){ app.$off(‘reduce’);}··· 全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;example03&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;example03&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {％raw％} {{num}} {％endraw％} &lt;p&gt;&lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;p&gt;&lt;button onclick=\"reduce()\"&gt;reduce&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onclick=\"reduceOnce()\"&gt;reduceOnce&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onclick=\"off()\"&gt;off&lt;/button&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ num:1 }, methods:{ add:function(){ this.num++; } } }); app.$on(\"reduce\",function(){ console.log(\"执行了reduce方法\"); this.num--; }) app.$once('reduceOnce',function(){ console.log('只执行一次的方法'); this.num--; }); function reduce(){ app.$emit('reduce'); } function reduceOnce(){ app.$emit('reduceOnce'); } //关闭事件 function off(){ app.$off('reduce'); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2-0-【第四季】第4节-内置组件-slot讲解","date":"2020-03-20T10:45:02.000Z","path":"/posts/bc1fc6de/","text":"Vue2.0 【第四季】第4节 内置组件 -slot讲解 第4节 内置组件 -slot讲解slot是标签的内容扩展，也就是说：你用slot就可以在自定义组件时传递给组件内容，组件接收内容并输出。 先来定义一个&lt;da0sy&gt;&lt;/da0sy&gt;的组件，这个组件用来显示博主的一些信息。 我们在Vue 构造器里的data中给出了信息，信息如下：（博客地址，网名，使用技能） 1234567data:{ da0syData:{ bolgUrl:'https://www.cnblogs.com/Elva3zora/', netName:'da0sy', skill:'Web前端' }}, 我们用&lt;template&gt;&lt;/template&gt;标签的方式定义了组件： 1234567&lt;template id=\"tmp\"&gt; &lt;div&gt; &lt;p&gt;博客地址：&lt;/p&gt; &lt;p&gt;网名：&lt;/p&gt; &lt;p&gt;技术类型：&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 我们现在就可以用slot功能让组件接收传递过来的值，并在模板中接收显示。 slot的使用需要两步： 1、在HTML的组件中用slot属性传递值。 12345&lt;da0sy&gt; &lt;span slot=\"blogUrl\"&gt;{{da0syData.blogUrl}}&lt;/span&gt; //传递 &lt;span slot=\"netName\"&gt;{{da0syData.netName}}&lt;/span&gt; &lt;span slot=\"skill\"&gt;{{da0syData.skill}}&lt;/span&gt;&lt;/da0sy&gt; 2、在组件模板中用标签接收值。 1234567&lt;template id=\"tep\"&gt; &lt;div&gt; &lt;p&gt;博客地址：&lt;slot name=\"blogUrl\"&gt;&lt;/slot&gt;&lt;/p&gt; //接收 &lt;p&gt;网名：&lt;slot name=\"netName\"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;技术类型：&lt;slot name=\"skill\"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 我们贴出这个案例的全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Slot content extend Demo&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Slot content extend Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;da0sy&gt; &lt;span slot=\"blogUrl\"&gt;{{da0syData.blogUrl}}&lt;/span&gt; //传递 &lt;span slot=\"netName\"&gt;{{da0syData.netName}}&lt;/span&gt; &lt;span slot=\"skill\"&gt;{{da0syData.skill}}&lt;/span&gt; &lt;/da0sy&gt; &lt;/div&gt; &lt;template id=\"tep\"&gt; &lt;div&gt; &lt;p&gt;博客地址：&lt;slot name=\"blogUrl\"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;网名：&lt;slot name=\"netName\"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;技术类型：&lt;slot name=\"skill\"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/javascript\"&gt; var da0sy = { template:\"#tep\" } var app = new Vue({ el:'#app', data:{ da0syData:{ blogUrl:'https://www.cnblogs.com/Elva3zora/', netName:'Cardiac_Dejavu', skill:\"web前端\" } }, components:{ \"da0sy\":da0sy } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2-0-【第四季】第2节-实例方法","date":"2020-03-20T10:43:23.000Z","path":"/posts/9530e9bf/","text":"Vue2.0 【第四季】第2节 实例方法 第2节 实例方法一、$mount方法$mount方法是用来挂载我们的扩展的，我们先来复习一下扩展的写法。 这里我们作了da0sy的扩展，然后用$mount的方法把da0sy挂载到DOM上，我们也生成了一个Vue的实例，直接看代码。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Examples Method Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Examples Method Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var da0sy = Vue.extend({ template:`&lt;p&gt;{{message}}&lt;/p&gt;`, data:function(){ return { message:'Hello ,I am da0sy' } } }) var vm = new da0sy().$mount(\"#app\") &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 二、$destroy()卸载方法用$destroy()进行卸载。 我写了一个button按钮，点击后卸载整个挂载。 html: 1&lt;p&gt;&lt;button onclick=\"destroy()\"&gt;卸载&lt;/button&gt;&lt;/p&gt; js: 123function destroy(){ vm.$destroy();} 全部代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Examples Method Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Examples Method Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;p&gt;&lt;button onclick=\"destroy()\"&gt;卸载&lt;/button&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var da0sy = Vue.extend({ template:`&lt;p&gt;{{message}}&lt;/p&gt;`, data:function(){ return { message:'Hello ,I am da0sy' } }, mounted:function(){ console.log(\"mounted 被创建！\"); }, destroyed:function(){ console.log(\"destroy 销毁之后\"); } }) var vm = new da0sy().$mount(\"#app\"); function destroy(){ vm.$destroy(); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text PS:$destroy()后边必须要有括号，没有括号是无用的。 三、$forceUpdate()更新方法1vm.$forceUpdate(); 全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Examples Method Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Examples Method Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;p&gt;&lt;button onclick=\"destroy()\"&gt;卸载&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onclick=\"reload()\"&gt;刷新&lt;/button&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var da0sy = Vue.extend({ template:`&lt;p&gt;{{message}}&lt;/p&gt;`, data:function(){ return { message:'Hello ,I am da0sy' } }, mounted:function(){ console.log(\"mounted 被创建！\"); }, destroyed:function(){ console.log(\"destroy 销毁之后\"); } }) var vm = new da0sy().$mount(\"#app\"); function destroy(){ vm.$destroy(); } function reload(){ vm.$forceUpdate(); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 四、$nextTick()数据修改方法当Vue构造器里的data值被修改完成后会调用这个方法，相当于一个钩子函数，和构造器里的updated生命周期很像。 123456function tick(){ vm.message=\"update message info \"; vm.$nextTick(function(){ console.log('message更新完后我被调用了'); })} 同样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Examples Method Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Examples Method Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;p&gt;&lt;button onclick=\"destroy()\"&gt;卸载&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onclick=\"reload()\"&gt;刷新&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onclick=\"tick()\"&gt;更改数据&lt;/button&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; var da0sy = Vue.extend({ template:`&lt;p&gt;{{message}}&lt;/p&gt;`, data:function(){ return { message:'Hello ,I am da0sy' } }, mounted:function(){ console.log(\"mounted 被创建！\"); }, destroyed:function(){ console.log(\"destroy 销毁之后\"); }, updated:function(){ console.log(\"update 更新之后\"); } }) var vm = new da0sy().$mount(\"#app\"); function destroy(){ vm.$destroy(); } function reload(){ vm.$forceUpdate(); } function tick(){ vm.message=\"update message info \"; vm.$nextTick(function(){ console.log('message更新完后我被调用了'); }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第四季】第1节 实例入门-实例属性","date":"2020-03-20T10:40:37.000Z","path":"/posts/99aca906/","text":"Vue2.0 【第四季】第1节 实例入门-实例属性 第1节 实例入门-实例属性概述：实例就是在构造器外部操作构造器内部的属性选项或者方法，就叫做实例？实例的作用就是给原生的或者其他javascript框架一个融合的接口或者说是机会，让Vue和其他框架一起使用。 一、Vue和Jquery.js一起使用下载并引入jQuery框架下载可以去官网进行下载，我这里使用的版本是3.4.1，下载好后在需要的页面引入就可以了。当然你还有很多其它的方法引入jquery，只要可以顺利引入就可以了。 1&lt;script type=\"text/javascript\" src=\"../assets/js/jquery-3.4.1.min.js\"&gt;&lt;/script&gt; 试着做一个案例，在DOM被挂载后修改里边的内容： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;example methods Demo&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;example methods Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ message:'hello world!' }, mounted:function(){ $(\"#app\").html('我是jQuery~！'); } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 现在页面显示是：我是jQuery，而不是hello Vue了。 二、实例调用自定义方法在Vue的构造器里我们写一个add方法，然后我们用实例的方法调用它。 构造器里的add方法： 12345methods:{ add:function(){ console.log(\"调用了ADD方法\"); }} 实例调用： 1app.add(); 全部代码： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;example methods Demo&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;example methods Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ message:'hello world!' }, mounted:function(){ $(\"#app\").html('我是jQuery~！'); }, methods:{ add:function(){ console.log(\"调用了构造器内部的ADD方法\"); } } }) app.add(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text PS：我们有可能把app.add()的括号忘记或省略，这时候我们得到的就是方法的字符串，但是并没有执行，所以必须要加上括号。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"ES6 第四节 扩展运算符和rest运算符","date":"2020-03-20T10:38:56.000Z","path":"/posts/a0b5abf4/","text":"ES6 第四节 扩展运算符和rest运算符@(ES6)[ES6] [toc] 第四节 扩展运算符和rest运算符扩展运算符和rest运算符，都是…（三个点）。它们可以很好的为我们解决参数和对象数组未知情况下的编程，让我们的代码更健壮和简洁。 对象扩展运算符（…）：当编写一个方法时，我们允许它传入的参数是不确定的。这时候可以使用对象扩展运算符来作参数，看一个简单的列子： 1234567function da0sy(...arg){ console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]);}da0sy(1,2,3); 这时我们看到控制台输出了 1，2，3，undefined，这说明是可以传入多个值，并且就算方法中引用多了也不会报错。 扩展运算符的用处：我们先用一个例子说明，我们声明两个数组arr1和arr2，然后我们把arr1赋值给arr2，然后我们改变arr2的值，会发现arr1的值也变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。 12345let arr1=['w','dd','aaa'];let arr2=arr1;console.log(arr2);arr2.push('todo');console.log(arr1); 控制台输出： 12[\"w\", \"dd\", \"aaa\"][\"w\", \"dd\", \"aaa\", \"todo\"] 可以利用对象扩展运算符解决这个问题，改一下代码： 1234567let arr1=['w','dd','aaa'];//let arr2=arr1;let arr2=[...arr1]; //表示arr1里的每一个元素console.log(arr2);arr2.push('todo');console.log(arr2);console.log(arr1); 现在的结果就变成： 123[\"w\", \"dd\", \"aaa\"][\"w\", \"dd\", \"aaa\", \"todo\"][\"w\", \"dd\", \"aaa\"] //arr1的值并没有改变 rest运算符eg： 12345function da0sy(first,...arg){ console.log(arg.length);}da0sy(0,1,2,3,4,5,6,7); 控制台打印出7，说明arg里有7个数组元素，这就是rest运算符的最简单用法。 如何循环输出rest运算符这里我们用for…of循环来进行打印出arg的值，只是一个简单的使用。 123456function da0sy(first,...arg){ for(let val of arg){ console.log(val); }}da0sy(0,1,2,3,4,5,6,7); for…of的循环可以避免我们开拓内存空间，增加代码运行效率，虽然最后要转换成ES5，没有什么差别，但是至少从代码量上我们少打了一些单词，这就是开发效率的提高。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"http://tomotoes.com/tags/ES6/"}]},{"title":"ES6 第六节 ES6数字操作","date":"2020-03-20T10:36:01.000Z","path":"/posts/266d507b/","text":"ES6 第六节 ES6数字操作@(ES6)[ES6] [toc] 第六节 ES6数字操作二进制和八进制二进制和八进制数字的声明并不是ES6的特性，做一个常识性的回顾。 二进制声明：二进制的英文单词是Binary，二进制的开始是0（零），第二个位置是b（大小写都可以实现），然后跟上二进制的值就可以了。 123//二进制声明 Binarylet binary = 0B010101;console.log(binary); 控制台输出：21 八进制声明：八进制的英文单词是Octal，也是以0（零）开始的，第二个位置是O（欧），然后跟上八进制的值就可以了。 12let Octal=0o666;console.log(Octal); 控制台输出：438 数字判断和转换数字验证Number.isFinite(xx)可以使用Number.isFinite( )来进行数字验证，只要是数字，不论是浮点型还是整型都会返回true，其他时候会返回false。 12345let a= 11/4;console.log(Number.isFinite(a));//trueconsole.log(Number.isFinite('da0sy'));//falseconsole.log(Number.isFinite(NaN));//falseconsole.log(Number.isFinite(undefined));//false NaN验证NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 1console.log(Number.isNaN(NaN)); 判断是否为整数Number.isInteger(xx)12let a=123.1;console.log(Number.isInteger(a)); //false 整数转换Number.parseInt(xxx)和浮点型转换Number.parseFloat(xxx)123let a='9.18';console.log(Number.parseInt(a)); //9console.log(Number.parseFloat(a)); //9.18 整数取值范围操作整数的操作是有一个取值范围的，它的取值范围就是2的53次方。我们先用程序来看一下这个数字是什么。 12let a = Math.pow(2,53)-1;console.log(a); //9007199254740991 在我们计算时会经常超出这个值，所以我们要进行判断，ES6提供了一个常数，叫做最大安全整数，以后就不需要我们计算了。 最大安全整数1console.log(Number.MAX_SAFE_INTEGER);//就是9007...上面那个数值 最小安全整数1console.log(Number.MIN_SAFE_INTEGER); //是-9007... 安全整数判断isSafeInteger()12let a= Math.pow(2,53)-1; //2的53次方console.log(Number.isSafeInteger(a));//true，安全 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"http://tomotoes.com/tags/ES6/"}]},{"title":"ES6 第五节 字符串模板","date":"2020-03-20T10:32:04.000Z","path":"/posts/5d5807df/","text":"ES6 第五节 字符串模板@(ES6)[ES6] [TOC] 第五节 字符串模板ES6对字符串新增的操作，最重要的就是字符串模版，字符串模版的出现让我们再也不用拼接变量了，而且支持在模板里有简单计算操作。 字符串模板先来看一个在ES5下我们的字符串拼接案例： 123let da0sy='黛西';let blog = '很高兴遇见你，我是你的老朋友'+da0sy+'。这节课我们学习字符串模版。';document.write(blog); ES5下必须用+da0sy+这样的形式进行拼接，这样很麻烦而且很容易出错。ES6新增了字符串模版，可以很好的解决这个问题。字符串模版不再使用‘xxx’这样的单引号，而是换成了xxx这种形式，也叫连接号。这时我们再引用da0sy变量就需要用${da0sy}这种形式了，我们对上边的代码进行改造: 123let da0sy='黛西';let blog = `很高兴遇见你，我是你的老朋友${da0sy}。这节课我们学习字符串模版。`;document.write(blog); 可以看到浏览器出现了和上边代码一样的结果。而且这里面支持html标签，可以试着输入一些： 123let da0sy='黛西';let blog = `很高兴遇见你，我是你的老朋友${da0sy}。&lt;br/&gt;这节课我们学习字符串模版。`;document.write(blog); 对运算的支持1234let a=1;let b=2;let result=`${a+b}`;document.write(result); 页面输出为3.强大的字符串模版，在实际开发中，我们可以让后台写一个活动页面，然后轻松的输出给用户。 字符串查找ES6还增加了字符串的查找功能，而且支持中文。 查找是否存在：先来看一下ES5的写法，其实这种方法并不实用，给我们的索引位置，我们自己还要确定位置。 123let da0sy = '黛西';let blog = '很高兴遇见你，我是你的老朋友黛西。这节课我们学习字符串模版。';document.write(blog.indexOf(da0sy)); 网页中输出了14，我们还要自己判断。 ES6直接用includes就可以判断，不再返回索引值。 123let da0sy = '黛西';let blog = '很高兴遇见你，我是你的老朋友黛西。这节课我们学习字符串模版。';document.write(blog.includes(da0sy)); 网页输出true，说明这句话里有黛西。 判断开头是否存在：1blog.startsWith(da0sy); 判断结尾是否存在：1blog.endsWith(da0sy); 复制字符串我们有时候是需要字符串重复的，比如分隔符和特殊符号，这时候复制字符串就派上用场了，语法很简单。 1document.write('da0sy|'.repeat(3)); 网页输出：da0sy|da0sy|da0sy| ES6对字符串还有一些其它操作，自行查询。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"http://tomotoes.com/tags/ES6/"}]},{"title":"Vue2-0-【第二季】第9节-Component-标签","date":"2020-03-20T10:07:24.955Z","path":"/posts/5c8856d1/","text":"title: Vue2.0 【第二季】第9节 Component 标签abbrlink: 126c4f17date: 2020-03-15 11:41:02tags: vue 2.0 Vue2.0 【第二季】第9节 Component 标签 第9节 Component 标签component标签是Vue框架自定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。 1、我们先在构造器外部定义三个不同的组件，分别是componentA,componentB和componentC1234567891011var componentA={ template:`&lt;div style=\"color:red\"&gt;I'm componentA.&lt;/div&gt;`}var componentB={ template:`div style=\"color:green\"&gt;I'm componentB.&lt;/div&gt;`}var componentC={ template:`&lt;div style=\"color:pink\"&gt;I'm componentC.&lt;/div&gt;`} 2、我们在构造器的components选项里加入这三个组件1234567891011var app = new Vue({ el:'#app', data:{ who:'componentA' }, components:{ \"componentA\":componentA, \"componentB\":componentB, \"componentC\":componentC, }}) 3、我们在html里插入component标签，并绑定who数据，根据who的值不同，调用不同的组件123&lt;div id=\"app\"&gt; &lt;component v-bind:is=\"who\"&gt;&lt;/component&gt;&lt;/div&gt; 这就是我们的组件标签的基本用法。我们提高一下，给页面加个按钮，每点一下更换一个组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;component-4&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;component-4&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;component v-bind:is=\"who\"&gt;&lt;/component&gt; &lt;button @click=\"changeComponent\"&gt;changeComponent&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var componentA={ template:`&lt;div style=\"color:red\"&gt;I'm componentA.&lt;/div&gt;` } var componentB={ template:`div style=\"color:green\"&gt;I'm componentB.&lt;/div&gt;` } var componentC={ template:`&lt;div style=\"color:pink\"&gt;I'm componentC.&lt;/div&gt;` } var app = new Vue({ el:'#app', data:{ who:'componentA' }, components:{ \"componentA\":componentA, \"componentB\":componentB, \"componentC\":componentC, }, methods:{ changeComponent:function(){ if(this.who=='componentA'){ this.who='componentB'; }else if(this.who=='componentB'){ this.who='componentC'; }else{ this.who='componentA'; } } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text Alt text Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"Hello World","date":"2020-03-19T11:55:41.387Z","path":"/posts/16107/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"ES6 第三节 变量的解构赋值","date":"2020-03-19T08:13:10.000Z","path":"/posts/3079772d/","text":"ES6 第三节 变量的解构赋值 第三节 变量的解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰。也许你还是不太明白，那先来一个最简单的数组解构赋值来进行赋值。 数据的解构赋值以前，为变量赋值，我们只能直接指定值。比如下面的代码： 123let a=0;let b=1;let c=2; 而现在我们可以用数组解构的方式来进行赋值。 1let [a,b,c]=[1,2,3]; 上面的代码表示，可以从数组中提取值，按照位置的对象关系对变量赋值。 数组模式和赋值模式统一：可以简单的理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。 1let [a,[b,c],d]=[1,[2,3],4]; 如果等号两边形式不一样，很可能获得undefined或者直接报错。 解构的默认值：解构赋值是允许你使用默认值的，先看一个最简单的默认true的例子。 12let [foo = true] =[];console.log(foo); //控制台打印出true 上边的例子数组中只有一个值，可能你会多少有些疑惑，我们就来个多个值的数组，并给他一些默认值。 12let [a,b=\"Da0sy\"]=['黛西']console.log(a+b); //控制台显示“黛西Da0sy” 现在我们对默认值有所了解，需要注意的是undefined和null的区别。 12let [a,b=\"Da0sy\"]=['黛西',undefined];console.log(a+b); //控制台显示“黛西Da0sy” undefined相当于什么都没有，b是默认值。 12let [a,b=\"Da0sy\"]=['黛西',null];console.log(a+b); //控制台显示“黛西null” null相当于有值，但值为null。所以b并没有取默认值，而是解构成了null。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 12let {foo,bar} = {foo:'Da0sy',bar:'黛西'};console.log(foo+bar); //控制台打印出了“Da0sy黛西” 注意：对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 圆括号的使用如果在解构之前就定义了变量，这时候你再解构会出现问题。下面是错误的代码，编译会报错。 123let foo;{foo} ={foo:'Da0sy'};console.log(foo); 要解决报错，使程序正常，我们这时候只要在解构的语句外边加一个圆括号就可以了。 123let foo;({foo} ={foo:'Da0sy'});console.log(foo); //控制台输出Da0sy 字符串解构字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。 123456const [a,b,c,d,e]=\"Da0sy\";console.log(a);console.log(b);console.log(c);console.log(d);console.log(e); 浏览器效果： Alt text 实战项目中解构Json数据格式还是很普遍的，有了ES6得帮助，提高了不少工作效率。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"http://tomotoes.com/tags/ES6/"}]},{"title":"ES6 第二节 新的声明方式","date":"2020-03-19T08:12:07.000Z","path":"/posts/38faf734/","text":"ES6 第二节 新的声明方式 第二节 新的声明方式以前我们在声明时只有一种方法，就是使用var来进行声明，ES6对声明的进行了扩展，现在可以有三种声明方式了。 字面理解ES6的三种声明方式： var：它是variable的简写，可以理解成变量的意思。 let：它在英文中是“让”的意思，也可以理解为一种声明的意思。 const：它在英文中也是常量的意思，在ES6也是用来声明常量的，常量你可以简单理解为不变的量。 var声明：var在ES6里是用来升级全局变量的，我们可以先作一个最简单的实例，用var声明一个变量a,然后用console.log进行输出。 12var a='Da0sy';console.log(a); 我们可以看到Da0sy在控制台已经被打印出来了。那如何理解它的作用是声明全局变量呢？我们用匿名函数给他进行一个包裹，然后在匿名函数中调用这个a变量，看看能不能调用到。 1234var a=\"Da0sy\";window.onload= function(){ console.log(a);} 可以看到控制台输出了Da0sy，这证明var确实是全局的。如果你觉得这个不够直观说明var是全局声明，还可以用区块的方式进行调用测试，先看下面的代码。 12345var a=2;{ var a=3;}console.log(a); 这时打印出来的值是3，因为var是全局声明的。 let局部声明通过两个简单的例子，我们对var的全局声明有了一定了解。那跟var相对应的是let，它是局部变量声明。还是上面的例子，我们试着在区块里用let声明。 12345var a=2;{ let a=3;}console.log(a); 这时候控制台打印出来的值就是2了。如果我们只在区块里声明，不再外部声明，我们打印a时就会报错，显示找不到变量。 1234{ let a=3;}console.log(a); 上面两个例子说明了let是局部变量声明，let声明只在区块内起作用，外部是不可以调用的。 有些刚接触JavaScript的小伙伴会疑惑了，我感觉let还没有var好用，其实let是防止你的数据污染的，在大型项目中是非常有用处的。现在看一个循环的例子，我们来看一下let的好处。 用var声明的循环1234for(let i=0;i&lt;10;i++){ console.log('循环体中:'+i);}console.log('循环体外:'+i); 执行时会发现控制台报错，找不到循环体外的i变量。 通过两种声明的比较，可以明白let在防止程序数据污染上还是很有用处的。我们要努力去习惯用let声明，减少var声明去污染全局空间，在vue的使用中也要注意这点。 const声明常量在程序开发中，有些变量是希望声明后在业务层就不再发生变化了，简单来说就是从声明开始，这个变量始终不变，就需要用const进行声明。 我们来一段用const声明错误的代码，在错误中学习const的特性也是非常好的。 123const a=\"Da0sy\";var a='黛西';console.log(a); 在编译这段代码的过程中，就已经报错，无法编译，原因就是我们const声明的变量是不可以改变的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"http://tomotoes.com/tags/ES6/"}]},{"title":"ES6 第一节 ES6的开发环境搭建","date":"2020-03-19T08:11:48.000Z","path":"/posts/52480212/","text":"ES6 第一节 ES6的开发环境搭建 第一节 ES6的开发环境搭建现在的Chrome浏览器已经支持ES6了，但是有些低版本的浏览器还是不支持ES6的语法，这就需要我们把ES6的语法自动的转变成ES5的语法。Webpack是有自动编译转换能力的，除了Webpack自动编译，我们还可以用Babel来完成。我们就使用Babel把ES6编译成ES5。 1、建立工程目录先建立一个项目的工程目录，并在目录下边建立两个文件夹：src和dist src：书写ES6代码的文件夹，写的js程序都放在这里。dist：利用Babel编译成的ES5代码的文件夹，在HTML页面需要引入的时这里的js文件。 2、编写index.html文件夹建立好后，我们新建一个index.html文件:（这里html快速生成选择html5） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;Hello ECMA Script 6&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;script src=\"./src/index.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; Hello ECMA Script 6&lt;/body&gt;&lt;/html&gt; 需要注意的是在引入js文件时，引入的是dist目录下的文件: src1234### 3、编写index.js在src目录下，新建index.js文件。这个文件很简单，我们只作一个a变量的声明，并用console.log()打印出来。 let a=1; //这是ES6的一种声明方式console.log(a); 1234567891011接下来我们需要把这个ES6的语法文件自动编程成ES5的语法文件：### 4、初始化项目在安装**Babel**之前，需要用```cnpm init```先初始化我们的项目。打开终端或者通过cmd打开命令行工具，进入项目目录，输入下边的命令：&gt; cnpm init -y-y代表全部默认同意，就不用一次次按回车设置信息。命令执行完成后，会在项目根目录下生产**package.json**文件： { “name”: “es6”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo \"Error: no test specified\" &amp;&amp; exit 1” }, “keywords”: [], “author”: “”, “license”: “ISC”} 12345可以根据自己的需要进行修改，比如我们修改name的值。### 5、全局安装Babel-cli在终端中输入以下命令： cnpm install -g babel-cli 1虽然已经安装了babel-cli，只是这样还不能成功进行转换，如果你不相信可以输入下边的命令试一下： babel src/index.js -o dist/index.js 1234你会发现，在dist目录下确实生产了index.js文件，但是文件并没有变化，还是使用的ES6的语法。因为我们还需要安装转换包才能成功转换。### 6、本地安装babel-preset-es2015 和 babel-cli cnpm install –save-dev babel-preset-es2015 babel-cli 1234安装完成后，我们可以看一下我们的package.json文件，已经多了devDependencies选项。### 7、新建.babelrc文件在根目录下新建.babelrc文件，并打开录入下面的代码： { “presets”:[ “es2015” ], “plugins”:[]} 12这个文件我们建立完成后，现在可以在终端输入的转换命令了，这次ES6成功转化为ES5的语法。 babel src/index.js -o dist/index.js 123### 8、简化转化命令在学习vue 的时候，可以使用```cnpm run build```直接利用webpack进行打包，在这里也希望利用这种方式完成转换。打开package.json文件，把文件中的build修改成下面的样子。 { “name”: “es6”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “build”: “babel src/index.js -o dist/index.js” }, “keywords”: [], “author”: “”, “license”: “ISC”, “devDependencies”: { “babel-cli”: “^6.24.1”, “babel-preset-es2015”: “^6.24.1” }} 修改好后，以后我们就可以使用 ```cnpm run build```来进行转换了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ES6","slug":"ES6","permalink":"http://tomotoes.com/tags/ES6/"}]},{"title":"Vue2.0 【第三季】第6节 Extends Option 扩展选项","date":"2020-03-16T11:20:14.000Z","path":"/posts/5cd62826/","text":"Vue2.0 【第三季】第6节 Extends Option 扩展选项 第6节 Extends Option 扩展选项通过外部增加对象的形式，对构造器进行扩展。它和第5节讲的混入非常的类似。 一、extends我们来看一个扩展的实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;extends&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;extends&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {% raw %} {{num}} {% endraw %} &lt;p&gt;&lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var extendsObj={ updated:function(){ console.log(\"我是扩展的updated\"); }, methods:{ add:function(){ console.log('我是扩展出来的方法'); this.num++; } } } var app = new Vue({ el:'#app', data:{ num:1 }, methods:{ add:function(){ console.log('我是原生的方法'); this.num++; } }, updated:function(){ console.log('我是原生的update'); }, extends:extendsObj }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 二、delimiters 选项因为这节课内容比较少，所以我们把要讲的最后一个选项一起讲了。delimiters的作用是改变我们插值的符号。Vue默认的插值是双大括号。但有时我们会有需求更改这个插值的形式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;extends&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;extends&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; ${ num } &lt;p&gt;&lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var extendsObj={ updated:function(){ console.log(\"我是扩展的updated\"); }, methods:{ add:function(){ console.log('我是扩展出来的方法'); this.num++; } } } var app = new Vue({ el:'#app', data:{ num:1 }, methods:{ add:function(){ console.log('我是原生的方法'); this.num++; } }, updated:function(){ console.log('我是原生的update'); }, extends:extendsObj, delimiters:['${','}'] }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 现在我们的插值形式就变成了${}。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第三季】第5节 Mixins 混入选项操作","date":"2020-03-16T11:19:37.000Z","path":"/posts/5479d7da/","text":"Vue2.0 【第三季】第5节 Mixins 混入选项操作 第5节 Mixins 混入选项操作Mixins一般有两种用途： 在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。 很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 一、Mixins的基本用法我们现在有个数字点击递增的程序，假设已经完成了，这时我们希望每次数据变化时都能够在控制台打印出提示：“数据发生变化”。 代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Mixins Option Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Mixins Option Demo&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;p&gt;num:{{ num }}&lt;/p&gt; &lt;P&gt;&lt;button @click=\"add\"&gt;增加数量&lt;/button&gt;&lt;/P&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //额外临时加入时，用于显示日志 var addLog={ updated:function(){ console.log(\"数据发生变化,变化成\"+this.num+\".\"); } } var app=new Vue({ el:'#app', data:{ num:1 }, methods:{ add:function(){ this.num++; } }, mixins:[addLog]//混入 }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text mixins的调用顺序：从执行的先后顺序来说，都是混入的先执行，然后构造器里的再执行，需要注意的是，这并不是方法的覆盖，而是被执行了两边。 在上边的代码的构造器里我们也加入了updated的钩子函数： 123updated:function(){ console.log(\"构造器里的updated方法。\")}, 这时控制台输出的顺序是： 12mixins数据放生变化,变化成2.构造器里的updated方法。 PS：当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。 三、全局API混入方式我们也可以定义全局的混入，这样在需要这段代码的地方直接引入js，就可以拥有这个功能了。我们来看一下全局混入的方法： 12345Vue.mixin({ updated:function(){ console.log('我是全局被混入的'); }}) PS：全局混入的执行顺序要前于混入和构造器里的方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第三季】第4节 Watch选项 监控数据","date":"2020-03-16T11:19:03.000Z","path":"/posts/2d04e911/","text":"Vue2.0 【第三季】第4节 Watch选项 监控数据 第4节 Watch选项 监控数据数据变化的监控经常使用，我们可以先来看一个简单的数据变化监控的例子。例如天气预报的穿衣指数，它主要是根据温度来进行提示的，当然还有其它的，咱们就不考虑了。 一、看一个监控变化的案例温度大于26度时，我们建议穿T恤短袖，温度小于26度大于0度时，我们建议穿夹克长裙，温度小于0度时我们建议穿棉衣羽绒服。 先来模拟一个温度变化的情况：我们使用按钮来加减温度。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;watch option&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;watch option&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;p&gt;今日温度：{{wendu}}度&lt;/p&gt; &lt;p&gt;穿衣建议：{{chuanyi}}&lt;/p&gt; &lt;p&gt;&lt;button @click=\"shenggao\"&gt;升高温度&lt;/button&gt;&lt;button @click=\"jiangdi\"&gt;降低温度&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ wendu:14, chuanyi:'夹克长裙' }, methods:{ shenggao:function(){ this.wendu+=5; }, jiangdi:function(){ this.wendu-=5; } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 二、用实例属性写watch监控1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;watch option&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;watch option&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;p&gt;今日温度：{{wendu}}度&lt;/p&gt; &lt;p&gt;穿衣建议：{{chuanyi}}&lt;/p&gt; &lt;p&gt;&lt;button @click=\"shenggao\"&gt;升高温度&lt;/button&gt;&lt;button @click=\"jiangdi\"&gt;降低温度&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ wendu:14, chuanyi:'夹克长裙' }, methods:{ shenggao:function(){ this.wendu+=5; }, jiangdi:function(){ this.wendu-=5; } }, watch:{ wendu:function(newVal,oldVal){ if(newVal&gt;=26){ this.chuanyi=\"T恤短袖\"; }else if(newVal&lt;26 &amp;&amp; newVal&gt;0){ this.chuanyi=\"夹克长裙\"; }else{ this.chuanyi=\"棉衣羽绒服\"; } } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text Alt text Alt text 但一般在js中不这么写，用一个数组把值存起来： 12345678910111213141516171819202122232425262728var chuanyiarray=['T恤短袖','夹克长裙','棉衣羽绒服'];var app = new Vue({ el:'#app', data:{ wendu:14, chuanyi:'夹克长裙' }, methods:{ shenggao:function(){ this.wendu+=5; }, jiangdi:function(){ this.wendu-=5; } }, watch:{ wendu:function(newVal,oldVal){ if(newVal&gt;=26){ this.chuanyi=chuanyiarray[0]; }else if(newVal&lt;26 &amp;&amp; newVal&gt;0){ this.chuanyi=chuanyiarray[1]; }else{ this.chuanyi=chuanyiarray[2]; } } }}) 有些时候我们会用实例属性的形式来写watch监控。也就是把我们watch卸载构造器的外部，这样的好处就是降低我们程序的耦合度，使程序变的灵活。 1app.$watch('xxx',function(){}) 还是上边的案例我们改成实例方法的模式： 1234567891011app.$watch('temperature',function(newVal,oldVal){ if(newVal&gt;=26){ this.suggestion=suggestion[0]; }else if(newVal&lt;26 &amp;&amp; newVal &gt;=0) { this.suggestion=suggestion[1]; }else{ this.suggestion=suggestion[2]; }}) 全部代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;watch option&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;watch option&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;p&gt;今日温度：{{wendu}}度&lt;/p&gt; &lt;p&gt;穿衣建议：{{chuanyi}}&lt;/p&gt; &lt;p&gt;&lt;button @click=\"shenggao\"&gt;升高温度&lt;/button&gt;&lt;button @click=\"jiangdi\"&gt;降低温度&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var chuanyiarray=['T恤短袖','夹克长裙','棉衣羽绒服']; var app = new Vue({ el:'#app', data:{ wendu:14, chuanyi:'夹克长裙' }, methods:{ shenggao:function(){ this.wendu+=5; }, jiangdi:function(){ this.wendu-=5; } } app.$watch('wendu',function(newVal,oldVal){ if(newVal&gt;=26){ this.chuanyi=chuanyiarray[0]; }else if(newVal&lt;26 &amp;&amp; newVal&gt;0){ this.chuanyi=chuanyiarray[1]; }else{ this.chuanyi=chuanyiarray[2]; } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果和上面是一样的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第三季】第3节 Methods Option 方法选项","date":"2020-03-16T11:18:25.000Z","path":"/posts/eca300ee/","text":"Vue2.0 【第三季】第3节 Methods Option 方法选项 第3节 Methods Option 方法选项在以前的学习中，已经大量的使用了构造器里的methods选项，但是并没有仔细和系统的讲解过，这节课把methods这个选项涉及的东西都讲一讲。 我们还是复习一下最简单的使用方法，一个数字，每点击一下按钮加1。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;methods Option&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;methods Option&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{ a }} &lt;p&gt;&lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ a:1 }, methods:{ add:function(){ this.a++ } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一、methods中参数的传递使用方法和正常的javascript传递参数的方法一样，分为两步： 在methods的方法中进行声明，比如我们给add方法加上一个num参数，就要写出add:function(num){} 调用方法时直接传递，比如我们要传递2这个参数，我们在button上就直接可以写&lt;button @click=”add(2)”&gt;&lt;/button&gt; 现在知道了加参数的方法，看一段完整的代码，代码中给add添加了num参数，并在按钮上调用传递了。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;methods Option&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;methods Option&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{ a }} &lt;p&gt;&lt;button @click=\"add(5)\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ a:1 }, methods:{ add:function(num){ if(num!=''){ this.a+=num; }else{ this.a++; } } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 这时，再点击按钮是每次加5个数字。 二、methods中的$event参数传递的$event参数都是关于你点击鼠标的一些事件和属性。我们先看看传递的方法。 传递： 1&lt;button @click=”add(5,$event)”&gt;add&lt;/button&gt; 我们这时候可以打印一下，看看event到底是个怎样的对象。你会发现，它包含了大部分鼠标事件的属性。 Alt text 三、native给组件绑定构造器里的原生事件在实际开发中经常需要把某个按钮封装成组件，然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的.native修饰器了。 现在我们把我们的add按钮封装成组件： 声明btn对象： 123var btn={ template:`&lt;button&gt;组件Add&lt;/button&gt;` } 在构造器里声明： 123components:{ \"btn\":btn } 用.native修饰器来调用构造器里的add方法 1&lt;p&gt;&lt;btn @click.native=\"add(3)\"&gt;&lt;/btn&gt;&lt;/p&gt; 全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;methods Option&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;methods Option&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{ a }} &lt;p&gt;&lt;button @click=\"add(5)\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;btn @click.native=\"add(3)\"&gt;&lt;/btn&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var btn={ template:`&lt;button&gt;组件Add&lt;/button&gt;` } var app=new Vue({ el:'#app', data:{ a:1 }, components:{ \"btn\":btn }, methods:{ add:function(num){ if(num!=''){ this.a+=num; }else{ this.a++; } } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 这种方法很常用，必须掌握。 四、作用域外部调用构造器里的方法这种不经常使用，如果你出现了这种情况，说明你的代码组织不够好。 1&lt;button onclick=\"app.add(4)\" &gt;外部调用构造器里的方法&lt;/button&gt; 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第三季】第2节 computed Option 计算选项","date":"2020-03-16T11:17:45.000Z","path":"/posts/7a60a0e2/","text":"Vue2.0 【第三季】第2节 computed Option 计算选项 第2节 computed Option 计算选项computed 的作用主要是对原数据进行改造输出。改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号…… 一、格式化输出结果我们先来做个读出价格的例子：我们读书的原始数据是price:100 但是我们输出给用户的样子是（￥100元）。 主要的javascript代码： 12345computed:{ newPrice:function(){ return this.price='￥' + this.price + '元'; }} 全部代码： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Computed Option 计算选项&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Computed Option 计算选项&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{newPrice}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ price:100 }, computed:{ newPrice:function(){ return this.price='￥' + this.price + '元'; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 二、用计算属性反转数组例如：我们得到了一个新闻列表的数组，它的顺序是安装新闻时间的顺序正序排列的，也就是早反生的新闻排在前面。这是反人类的，我们需要给它反转。这时我们就可以用到我们的计算属性了。 没有排序的新闻列表，是安装日期正序排列的。 123456var newsList=[ {title:'香港或就“装甲车被扣”事件追责 起诉涉事运输公司',date:'2017/3/10'}, {title:'日本第二大准航母服役 外媒：针对中国潜艇',date:'2017/3/12'}, {title:'中国北方将有明显雨雪降温天气 南方阴雨持续',date:'2017/3/13'}, {title:'起底“最短命副市长”：不到40天落马，全家被查',date:'2017/3/23'},]; 我们希望输出的结果： 起底“最短命副市长”：不到40天落马，全家被查-2017/3/23 中国北方将有明显雨雪降温天气 南方阴雨持续-2017/3/13 日本第二大准航母服役 外媒：针对中国潜艇-2017/3/12 香港或就“装甲车被扣”事件追责 起诉涉事运输公司-2017/3/10 我们的在computed里的javascript代码：我们用js原生方法给数组作了反转。 12345computed:{ reverseNews:function(){ return this.newsList.reverse(); }} 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;computed&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;computed&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;p&gt;{{newPrice}}&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"item in reversNews\"&gt;{{item.title}}-{{item.date}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var newsList=[ {title:'香港或就“装甲车被扣”事件追责 起诉涉事运输公司',date:'2017/3/10'}, {title:'日本第二大准航母服役 外媒：针对中国潜艇',date:'2017/3/12'}, {title:'中国北方将有明显雨雪降温天气 南方阴雨持续',date:'2017/3/13'}, {title:'起底“最短命副市长”：不到40天落马，全家被查',date:'2017/3/23'}, ]; var app = new Vue({ el:'#app', data:{ price:100, newsList:newsList }, computed:{ newPrice:function(){ return this.price='￥' + this.price + '元'; }, reversNews:function(){ return this.newsList.reverse(); } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 总结：computed 属性是非常有用，在输出数据前可以轻松的改变数据。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第三季】第1节 propsData Option 全局扩展的数据传递","date":"2020-03-16T11:16:58.000Z","path":"/posts/593dd63c/","text":"Vue2.0 【第三季】第1节 propsData Option 全局扩展的数据传递 第1节 propsData Option 全局扩展的数据传递这一季讲的是基础中的选项，选项就是在Vue构造器里的配置功能的前缀（Vue已经给我们定义好了），Vue有很多选项，我们将在这一级教程中一一介绍。 propsData 不是和属性有关，他用在全局扩展时进行传递数据。先回顾一下全局扩展的知识，作一个&lt;header&gt;&lt;/header&gt;的扩展标签出来。实际我们并比推荐用全局扩展的方式作自定义标签，我们学了组件，完全可以使用组件来做，这里只是为了演示propsData的用法。 代码如下： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;PropsData Option Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;PropsData Option Demo&lt;/h1&gt; &lt;hr&gt; &lt;header&gt;&lt;/header&gt; &lt;script type=\"text/javascript\"&gt; var header_a = Vue.extend({ template:`&lt;p&gt;{{message}}&lt;/p&gt;`, data:function(){ return { message:'Hello,I am Header' } } }); new header_a().$mount('header'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 扩展标签已经做好了，这时我们要在挂载时传递一个数字过去，我们就用到了propsData。 我们用propsData三步解决传值： 1.在全局扩展里加入props进行接收。propsData:{a:1} 2.传递时用propsData进行传递。props:[‘a’] 3.用插值的形式写入模板。 完整代码： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;propsData option&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;propsData option&lt;/h1&gt; &lt;hr&gt; &lt;header&gt;&lt;/header&gt; &lt;script type=\"text/javascript\"&gt; var header_a = Vue.extend({ template:'&lt;p&gt;{{message}}-{{a}}&lt;/p&gt;', data:function(){ return { message:'Hello , I am header!' } }, props:['a'] }); new header_a({propsData:{a:12}}).$mount('header'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 总结：propsData在实际开发中我们使用的并不多，我们在后边会学到Vuex的应用，他的作用就是在单页应用中保持状态和数据的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第二季】第8节 Component 父子组件关系","date":"2020-03-15T03:40:32.000Z","path":"/posts/af610746/","text":"Vue2.0 【第二季】第8节 Component 父子组件关系 第8节 Component 父子组件关系在实际开发中我们经常会遇到在一个自定义组件中要使用其他自定义组件，这就需要一个父子组件关系。 一、构造器外部写局部注册组件上节课我们都把局部组件的编写放到了构造器内部，如果组件代码量很大，会影响构造器的可读性，造成拖拉和错误。 我们把组件编写的代码放到构造器外部或者说单独文件。 我们需要先声明一个对象,对象里就是组件的内容。 123var monkeyComponent = { template:`&lt;div style=\"color:red;\"&gt;Monkey is from China!&lt;/div&gt;`} 声明好对象后在构造器里引用就可以了： 123456var app = new Vue({ el:'#app', components:{ \"monkey\":monkeyComponent }}) html中引用： 123&lt;div id=\"app\"&gt; &lt;monkey&gt;&lt;/monkey&gt; //引用&lt;/div&gt; 浏览器效果： Alt text 二、父子组件的嵌套我们先声明一个父组件，比如叫monkey，然后里边我们加入一个city组件，我们来看这样的代码如何写。 html文件： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;component-3&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;component-3&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;monkey&gt;&lt;/monkey&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var city = { template:`&lt;div style=\"color:green;\"&gt;siChuan of China.&lt;/div&gt;` } var monkeyComponent = { template:` &lt;div&gt; &lt;p&gt;Monkey is from China!&lt;/p&gt; &lt;city&gt;&lt;/city&gt; &lt;/div&gt; `, components:{ \"city\":city } } var app = new Vue({ el:'#app', components:{ \"monkey\":monkeyComponent } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第二季】第7节 Component 组件 props 属性设置","date":"2020-03-15T03:39:55.000Z","path":"/posts/9e36f38d/","text":"Vue2.0 【第二季】第7节 Component 组件 props 属性设置 第7节 Component 组件 props 属性设置props选项就是设置和获取标签上的属性值的，例如我们有一个自定义的组件,这时我们想给他加个标签属性写成 意思就是熊猫来自中国，当然这里的China可以换成任何值。定义属性的选项是props。 一、定义属性并获取属性值定义属性我们需要用props选项，加上数组形式的属性名称，例如：props:[‘here’]。在组件的模板里读出属性值只需要用插值的形式，例如 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;component-2&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;component-2&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;monkey here=\"China\"&gt;&lt;/monkey&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', components:{ //可以定义多个 \"monkey\":{ //这块必须是字符串，不然相当于没定义 template:'&lt;div style=\"color:green\"&gt;Monkey is from {{here}}.&lt;/div&gt;', props:['here'] } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 上面的代码定义了monkey的组件，并用props设置了here的属性值，在here属性值里传递了China给组件。 最后输出的结果是绿色字体的Monkey is from China. 二、属性中带’ - ‘的处理方式我们在写属性时经常会加入’-‘来进行分词，比如：&lt;monkey from-here=\"China\"&gt;&lt;/monkey&gt;，那这时我们在props里如果写成props:[‘form-here’]是错误的，我们必须用小驼峰式写法props:[‘formHere’]。（大驼峰：FromHere） html文件： 1&lt;monkey from-here=\"China\"&gt;&lt;/monkey&gt; js文件： 123456789var app = new Vue({ el:'#app', components:{ //可以定义多个 \"monkey\":{ //这块必须是字符串，不然相当于没定义 template:'&lt;div style=\"color:green\"&gt;Monkey is from {{fromHere}}.&lt;/div&gt;', props:['fromHere'] } }}) PS：因为这里有坑，所以还是少用-为好。 三、在构造器里向组件中传值把构造器中data的值传递给组件，我们只要进行绑定就可以了。就是我们第一季学的v-bind:xxx html文件： 1&lt;monkey v-bind:here=\"message\"&gt;&lt;/monkey&gt;或者简写：&lt;monkey :here=\"message\"&gt;&lt;/monkey&gt; js代码： 123456789101112var app = new Vue({ el:'#app', data:{ message:'China' }, components:{ //可以定义多个 \"monkey\":{ //这块必须是字符串，不然相当于没定义 template:'&lt;div style=\"color:green\"&gt;Monkey is from {{here}}.&lt;/div&gt;', props:['here'] } }}) 浏览器效果： Alt text 同样可以实现以上效果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第二季】第6节 Component 初识组件","date":"2020-03-15T03:39:11.000Z","path":"/posts/f35f578e/","text":"Vue2.0 【第二季】第6节 Component 初识组件 第6节 Component 初识组件前言（废话）：component组件是Vue学习的重点！所以你必须学好Vue component。其实组件就是制作自定义的标签，这些标签在HTML中是没有的。比如：&lt;da0sy&gt;&lt;/da0sy&gt;，那我们就开始学习这种技巧吧。 一、全局化注册组件全局化就是在构造器的外部用Vue.component来注册，我们注册一个da0sy组件来体验一下。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;component-1&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;component-1&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;da0sy&gt;&lt;/da0sy&gt; //必须放在vue作用域里，这里是app &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.component('da0sy',{ ////只能定义一个 template:'&lt;div style=\"color:red\"&gt;我是全局的da0sy组件&lt;/div&gt;' }) var app = new Vue({ el:'#app', }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 我们在javascript里注册了一个组件，在HTML中调用了它。这就是最简单的一个组件的编写方法，并且它可以放到多个构造器的作用域里。 二、局部注册组件局部局部注册组件和全局注册组件是相对应的，局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;component-1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;component-1&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;monkey&gt;&lt;/monkey&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', components:{ //可以定义多个 \"monkey\":{ //这块必须是字符串，不然相当于没定义 template:`&lt;div style=\"color:green;\"&gt;局部注册的monkey标签&lt;/div&gt;` } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 从代码中你可以看出局部注册其实就是写在构造器里，但是你需要注意的是，,构造器里的components 是加s的，而全局注册是不加s的。 三、组件和指令的区别组件注册的是一个标签，而指令注册的是已有标签里的一个属性。在实际开发中我们还是用组件比较多，指令用的比较少。因为指令看起来封装的没那么好，这只是个人观点。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第二季】第5节 Template制作模板","date":"2020-03-14T06:35:54.000Z","path":"/posts/56d26f90/","text":"Vue2.0 【第二季】第5节 Template制作模板 第5节 Template制作模板一、直接写在选项里的模板直接在构造器里的template选项后边编写。这种写法比较直观，但是如果模板html代码太多，不建议使用。 js代码： 123456789var app=new Vue({ el:'#app', data:{ message:'hello Vue!' }, template:` &lt;h1 style=\"color:red\"&gt;我是选项模板&lt;/h1&gt; ` //这是Tab上的键}) 二、写在template标签里的模板这种写法更像是在写HTML代码，就算不会写Vue的人，也可以制作页面。 12345678910111213&lt;template id=\"demo2\"&gt; &lt;h2 style=\"color:red\"&gt;我是template标签模板&lt;/h2&gt;&lt;/template&gt;&lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ message:'hello Vue!' }, template:'#demo2' })&lt;/script&gt; 三、写在script标签里的模板这种写模板的方法，可以让模板文件从外部引入。 12345678910111213&lt;script type=\"x-template\" id=\"demo3\" &lt;!--src=\"...\"--&gt;&gt; &lt;h2 style=\"color:red\"&gt;我是script标签模板&lt;/h2&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ message:'hello Vue!' }, template:'#demo3' }) &lt;/script&gt; 这一节学习了Template的三种写法，以后学习到vue-cli的时候还会学到一种xxx.vue的写法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第二季】第4节 Vue的生命周期（钩子函数）","date":"2020-03-14T06:35:09.000Z","path":"/posts/84c2c618/","text":"Vue2.0 【第二季】第4节 Vue的生命周期（钩子函数） 第4节 Vue的生命周期（钩子函数）Vue一共有10个生命周期函数，我们可以利用这些函数在vue的每个阶段都进行操作数据或者改变内容。 其实在Vue的官网有一张图已经很好的诠释了生命周期，直接贴图，然后上程序代码。 Alt text 直接来看一段代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;生命周期&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;生命周期&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{count}} &lt;p&gt;&lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;button onclick=\"app.$destroy()\"&gt;销毁&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ count:1 }, methods:{ add:function(){ this.count++; } }, beforeCreate:function(){ console.log('1-beforeCreate 初始化之前'); }, created:function(){ console.log('2-created 创建完成'); }, beforeMount:function(){ console.log('3-beforeMount 挂载之前'); }, mounted:function(){ console.log('4-mounted 被挂载之后'); }, beforeUpdate:function(){ console.log('5-beforeUpdate 数据更新前'); }, updated:function(){ console.log('6-updated 被更新后'); }, activated:function(){ console.log('7-activated'); }, deactivated:function(){ console.log('8-deactivated'); }, beforeDestroy:function(){ console.log('9-beforeDestroy 销毁之前'); }, destroyed:function(){ console.log('10-destroyed 销毁之后') } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 同样的，试验一下： Alt text 点击add按钮后： Alt text 点击销毁后： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第二季】第3节 Vue.set全局操作","date":"2020-03-14T06:34:26.000Z","path":"/posts/37fb3230/","text":"Vue2.0 【第二季】第3节 Vue.set全局操作 第3节：Vue.set全局操作Vue.set 的作用就是在构造器外部操作构造器内部的数据、属性或者方法。比如在vue构造器内部定义了一个count为1的数据，我们在构造器外部定义了一个方法，要每次点击按钮给值加1.就需要用到Vue.set。 一、引用构造器外部数据什么是外部数据，就是不在Vue构造器里的data处声明，而是在构造器外部声明，然后在data处引用。外部数据的加入让程序更加灵活，我们可以在外部获取任何想要的数据形式，然后让data引用。 看一个简单的代码： 12345678910//在构造器外部声明数据var outData={ count:1, goodName:'car'};var app=new Vue({ el:'#app', //引用外部数据 data:outData}) html代码： 123&lt;div id=\"app\"&gt; {{count}}&lt;/div&gt; 浏览器依然输出1 二、在外部改变数据的三种方法：1、用Vue.set改变js中加入： 123function add(){ Vue.set(outData,'count',4); } html改为： 1234&lt;div id=\"app\"&gt; {{count}}&lt;/div&gt;&lt;p&gt;&lt;button onclick=\"add()\"&gt;add&lt;/button&gt;&lt;/p&gt; 点击按钮数字就会变成4： Alt text 2、用Vue对象的方法添加js中加入： 123function add(){ app.count++;} 浏览器实现按钮逐次加一 3、直接操作外部数据js中加入： 123function add(){ outData.count++;} 同样实现按钮逐次加一的效果 其实这三种方式都可以操作外部的数据，Vue也给我们增加了一种操作外部数据的方法。 三、为什么要有Vue.set的存在？由于Javascript的限制，Vue不能自动检测以下变动的数组。 当你利用索引直接设置一个项时，vue不会为我们自动更新。 当你修改数组的长度时，vue不会为我们自动更新。 看一段代码： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;Vue.set 全局操作&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Vue.set 全局操作&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\" aa in arr\"&gt;{{aa}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;button onclick=\"add()\"&gt;外部添加&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; function add(){ console.log(\"我已经执行了\"); app.arr[1]='ddd'; //Vue.set(app.arr,1,'ddd'); } var outData={ arr:['aaa','bbb','ccc'] }; var app=new Vue({ el:'#app', data:outData }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这时我们的界面是不会自动更新数组的，我们需要用Vue.set(app.arr,1,’ddd’)来设置改变，vue才会给我们自动更新，这就是Vue.set存在的意义。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vye2.0 【第二季】第2节 vue.extend构造器的延伸","date":"2020-03-14T06:33:47.000Z","path":"/posts/f7bf78f1/","text":"Vue2.0 【第二季】第2节 Vue.extend构造器的延伸 一、什么是Vue.extendVue.extend 返回的是一个“扩展实例构造器”,也就是预设了部分选项的Vue实例构造器。经常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件名称作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂载到自定义元素上。 由于我们还没有学习Vue的自定义组件，所以我们先看跟组件无关的用途。 二、自定义无参数标签我们想象一个需求，需求是这样的，要在博客页面多处显示作者的网名，并在网名上直接有链接地址。我们希望在html中只需要写，这和自定义组件很像，但是他没有传递任何参数，只是个静态标签。 html代码： 1&lt;author&gt;&lt;/author&gt; js代码：我们的Vue.extend该登场了，我们先用它来编写一个扩展实例构造器。代码如下： 1234567891011121314var authorURL = Vue.extend({ template:\"&lt;p&gt;&lt;a :href='authorURL'&gt;{{authorName}}&lt;/a&gt;&lt;/p&gt;\", data:function(){ return{ authorName:'da0sy', authorURL:\"https://www.cnblogs.com/Elva3zora/\" } }});//这时html中的标签还是不起作用的，因为扩展实例构造器是需要挂载的，我们再进行一次挂载。new authorURL().$mount(\"author\");//这时我们在html写&lt;author&gt;&lt;/author&gt;就是管用的。 我们看一下全部代码： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;vue.extend-扩展实例构造器&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;vue.extend-扩展实例构造器&lt;/h1&gt; &lt;hr&gt; &lt;author&gt;&lt;/author&gt; &lt;script type=\"text/javascript\"&gt; var authorExtend = Vue.extend({ template:\"&lt;p&gt;&lt;a :href='authorUrl'&gt;{{authorName}}&lt;/a&gt;&lt;/p&gt;\", data:function(){ return{ authorName:'JSPang', authorUrl:'http://www.jspang.com' } } }); new authorExtend().$mount('author'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 点击链接链接到我们的地址： Alt text 三、挂载到普通标签上组件使用以上方式，但如果真的要使用扩展实例构造器，建议通过HTML标签上的id或者class来生成扩展实例构造器，Vue.extend里的代码是一样的，只是在挂载的时候，我们用类似jquery的选择器的方法，来进行挂载就可以了。 html代码： 1&lt;div id=\"author\"&gt;&lt;/div&gt; 相应的js代码改为： 1new authorURL().$mount(\"#author\"); PS：今天学到的快捷键：SHIFT+WINDOE键+下 可以快速小化窗口至任务栏 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第二季】第1节 Vue.directive自定义指令","date":"2020-03-14T06:33:00.000Z","path":"/posts/6f4ade4f/","text":"Vue2.0 【第二季】第1节 Vue.directive自定义指令 一、什么是全局API？全局API并不在构造器里，而是先声明全局变量或者直接在Vue上定义一些新功能，Vue内置了一些全局API，比如我们今天要学习的指令Vue.directive。说的简单些就是，在构造器外部用Vue提供给我们的API函数来定义新的功能。 二、 Vue.directive自定义指令我们在第一季就学习了内部指令，我们也可以定义一些属于自己的指令，比如我们要定义一个v-Da0sy的指令，作用就是让文字变成红色。 在自定义指令前我们写一个小功能，在页面上有一个数字为10，数字的下面有一个按钮，我们每点击一次按钮后，数字加1。html代码： 1234&lt;div id=\"app\"&gt; &lt;div&gt;{{num}}&lt;/div&gt; &lt;p&gt;&lt;button @click='add'&gt;ADD&lt;/button&gt;&lt;/p&gt;&lt;/div&gt; js代码： 1234567891011var app = new Vue({ el:'#app', data:{ num:10 }, methods:{ add:function(){ this.num++; } }}) 浏览器效果： Alt text 写好了这个功能，我们现在就自己定义一个全局的指令。我们这里使用Vue.directive( );html代码： 1234&lt;div id=\"app\"&gt; &lt;div v-da0sy='color'&gt;{{num}}&lt;/div&gt; &lt;p&gt;&lt;button @click='add'&gt;ADD&lt;/button&gt;&lt;/p&gt;&lt;/div&gt; js代码： 12345678910111213141516Vue.directive(\"da0sy\",function(el,binding,vnode){ el.style=\"color:\"+binding.value;});var app = new Vue({ el:'#app', data:{ num:10, color:'red' }, methods:{ add:function(){ this.num++; } }}); 浏览器效果： Alt text 可以看到数字已经变成了红色，说明自定义指令起到了作用。可能您看这个代码还是有些不明白的，比如传入的三个参数到底是什么。 三、自定义指令中传递的三个参数 el：指令所绑定的元素，可以用来直接操作DOM。（这里是div） binding：一个对象，包含指令的很多信息。（这里是对象{name: “da0sy”, rawName: “v-da0sy”, value: “red”, expression: “color”, modifiers: {…}, …}） vnode：Vue编译生成的虚拟节点。 四、自定义指令的生命周期自定义指令有五个生命周期（也叫钩子函数），分别是bind，inserted，update，componentUpdated，unbind 1、bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。2、inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。3、update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。4、componentUpdated：被绑定元素所在模板完成一次更新周期时调用。5、unbind：只调用一次，指令与元素解绑时调用。 html代码： 12345678&lt;div id=\"app\"&gt; &lt;div v-da0sy='color'&gt;{{num}}&lt;/div&gt; &lt;p&gt;&lt;button @click='add'&gt;ADD&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt; &lt;button onclick=\"unbind()\"&gt;解绑&lt;/button&gt;&lt;/p&gt; js代码： 1234567891011121314151617181920212223242526272829303132333435function unbind(){ app.$destroy();} Vue.directive(\"da0sy\",{ bind:function(el,binding){//被绑定 console.log('1 - bind'); el.style=\"color:\"+binding.value; }, inserted:function(){//绑定到节点 console.log('2 - inserted'); }, update:function(){//组件更新 console.log('3 - update'); }, componentUpdated:function(){//组件更新完成 console.log('4 - componentUpdated'); }, unbind:function(){//解绑 console.log('5 - unbind'); }}); var app = new Vue({ el:'#app', data:{ num:10, color:'red' }, methods:{ add:function(){ this.num++; } }}); 浏览器效果： Alt text 点击ADD按钮后： Alt text 点击unbind解除绑定后： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第8节 v-pre & v-cloak & v-once","date":"2020-03-13T12:37:48.000Z","path":"/posts/3dd860b8/","text":"Vue2.0 【第一季】 第8节 v-pre &amp; v-cloak &amp; v-once v-pre 指令在模板中跳过vue的编译，直接输出原始值。就是在标签中加入v-pre就不会输出vue中的data值了。html代码： 1&lt;div v-pre&gt;{{message}}&lt;/div&gt; 这时并不会输出我们的message值，不进行渲染，而是直接在网页中显示 v-cloak 指令在vue渲染完指定的整个DOM后才进行显示。它必须和CSS样式一起使用： 可以使用 v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除。 1&lt;div v-cloak&gt;{{message}}&lt;/div&gt; 当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会闪现出 Vue 源代码，再显示渲染的内容。 我们可以使用 v-cloak 指令来解决这一问题：html代码： 123&lt;div id=\"app\" v-cloak&gt; {{message}}&lt;/div&gt; style中，css代码： 123[v-cloak] { display: none;} 这样就会解决屏幕闪动的问题。 v-once 指令在第一次DOM时进行渲染，渲染完成后视为静态内容，跳出以后的渲染过程。（相当于只渲染一次） 12&lt;div v-once&gt;第一次绑定的值：{{message}}&lt;/div&gt;&lt;div&gt;&lt;input type=\"text\" v-model=\"message\"&gt;&lt;/div&gt; 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第7节 v-bind指令","date":"2020-03-13T12:37:06.000Z","path":"/posts/f52403cb/","text":"Vue2.0 【第一季】 第7节 v-bind指令 第7节 v-bind指令v-bind是处理HTML中的标签属性的例如，我们绑定img上的src属性，进行动态赋值： html文件： 123&lt;div id=\"app\"&gt; &lt;img v-bind:src=\"imgSrc\" width=\"200px\" /&gt;&lt;/div&gt; 在html中我们用v-bind:src=”imgSrc”的动态绑定了src的值，这个值是在vue构造器里的data属性中找到的。 js文件： 123456var app = new Vue({ el:'#app', data:{ imgSrc:'http://a0.att.hudong.com/78/52/01200000123847134434529793168.jpg' }}); 我们在data对象在中增加了imgSrc属性来供html调用。 v-bind缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写方法，用冒号代替 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; 绑定CSS样式在工作中我们经常使用v-bind来绑定css样式： 在绑定CSS样式时，绑定的值必须在vue中的data属性中进行声明。 1、直接绑定class样式html代码： 1&lt;div :class=\"className\"&gt;1、绑定class&lt;/div&gt; style中的css样式： 12345&lt;style&gt; .classA{ color: red; }&lt;/style&gt; js代码： 123456var app = new Vue({ el:'#app', data:{ className:'classA', }}); 浏览器效果： Alt text 2、绑定classA并进行判断，在isOK为true时显示样式，在isOk为false时不显示样式。html代码： 1&lt;div :class=\"{classA:isOk}\"&gt;2、绑定Class中的判断&lt;/div&gt; CSS同上；js代码： 123456var app = new Vue({ el:'#app', data:{ isOk:true }}); 浏览器效果： Alt text 另：html代码： 123456&lt;div :class=\"{classA:isOk}\"&gt;2、绑定Class中的判断&lt;/div&gt;&lt;hr&gt;&lt;div&gt; &lt;input type=\"checkbox\" id=\"isOk\" v-model=\"isOk\"&gt; &lt;label for=\"isOk\"&gt;isOk={{isOk}}&lt;/label&gt;&lt;/div&gt; CSS样式不变；js代码不变 浏览器效果： Alt text 3、绑定class中的数组html代码： 1&lt;div :class=\"[classA,classB]\"&gt;3、绑定class中的数组&lt;/div&gt; js代码： 1234567var app = new Vue({ el:'#app', data:{ classA:'classA', classB:'classB' }}); 浏览器效果： Alt text 4、绑定class中使用三元表达式判断1&lt;div :class=\"isOk?classA:classB\"&gt;4、绑定class中的三元表达式判断&lt;/div&gt; CSS不变；js代码： 12345678var app = new Vue({ el:'#app', data:{ isOk:false, //false实现classB样式，true实现classA样式 classA:'classA', classB:'classB' }}); 浏览器效果： Alt text 5、绑定style1&lt;div :style=\"{color:red,fontSize:font}\"&gt;5、绑定style&lt;/div&gt; CSS不需；js代码： 1234567var app = new Vue({ el:'#app', data:{ red:'red', font:'20px' }}); 浏览器效果： Alt text 6、用对象绑定style样式1&lt;div :style=\"styleObject\"&gt;6、用对象绑定style样式&lt;/div&gt; js代码： 123456789var app=new Vue({ el:'#app', data:{ styleObject:{ fontSize:'24px', color:'green' } }}) 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第6节 v-model指令","date":"2020-03-13T12:36:37.000Z","path":"/posts/563a9848/","text":"Vue2.0 【第一季】 第6节 v-model指令 第6节 v-model指令v-model指令，我理解为绑定数据源。就是把数据绑定在特定的表单元素上，可以很容易的实现双向数据绑定。 一、一个最简单的双向数据绑定代码：html文件： 12345&lt;div id=\"app\"&gt; &lt;p&gt;原始文本信息：{{message}}&lt;/p&gt; &lt;h3&gt;文本框&lt;/h3&gt; &lt;p&gt;v-model:&lt;input type=\"text\" v-model=\"message\"&gt;&lt;/p&gt;&lt;/div&gt; js代码： 123456var app=new Vue({ el:'#app', data:{ message:'hello Vue!' } }) 完整代码： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;v-model 实例&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-model 实例&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;p&gt;原始文本信息：{{message}}&lt;/p&gt; &lt;h3&gt;文本框&lt;/h3&gt; &lt;p&gt;v-model:&lt;input type=\"text\" v-model=\"message\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ message:'hello Vue!' } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 看一下浏览器效果： Alt text 二、修饰符 .lazy：取代 input 监听 change 事件。 .number：输入字符串转为数字。 .trim：输入去掉首尾空格。 完整代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;v-model 实例&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-model 实例&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;p&gt;原始文本信息：{{message}}&lt;/p&gt; &lt;h3&gt;文本框&lt;/h3&gt; &lt;p&gt;v-model：&lt;input type=\"text\" v-model=\"message\"&gt;&lt;/p&gt; &lt;p&gt;v-model.lazy：&lt;input type=\"text\" v-model.lazy=\"message\"&gt;&lt;/p&gt; &lt;p&gt;v-model.number：&lt;input type=\"text\" v-model.number=\"message\"&gt;&lt;/p&gt; &lt;p&gt;v-model.trim：&lt;input type=\"text\" v-model.trim=\"message\"&gt;&lt;/p&gt; &lt;!-- 去空格 --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ message:'hello Vue!' } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ** .lazy**浏览器效果： Alt text 点击输入文本框外的地方： Alt text ** .number**浏览器效果： Alt text 但有一种例外情况： Alt text ** .trim**浏览器效果： Alt text 三、文本区域加入数据绑定html代码： 1&lt;textarea cols=\"30\" rows=\"10\" v-model=\"message\"&gt;&lt;/textarea&gt; 浏览器效果： Alt text 四、多选按钮绑定一个值html代码： 123&lt;h3&gt;多选框绑定一个值&lt;/h3&gt;&lt;input type=\"checkbox\" id=\"isTrue\" v-model=\"isTrue\"&gt;&lt;label for=\"isTrue\"&gt;{{isTrue}}&lt;/label&gt; js代码： 123456var app = new Vue({ el:'#app', data:{ isTrue:true }}) 浏览器效果： Alt text 五、多选绑定一个数组html代码： 12345678910&lt;h3&gt;多选绑定一个数组&lt;/h3&gt;&lt;p&gt; &lt;input type=\"checkbox\" id=\"Da0sy\" value=\"Da0sy\" v-model=\"web_Names\"&gt; &lt;label for=\"Da0sy\"&gt;Da0sy&lt;/label&gt;&lt;br/&gt; &lt;input type=\"checkbox\" id=\"Daisy\" value=\"Daisy\" v-model=\"web_Names\"&gt; &lt;label for=\"Daisy\"&gt;Daisy&lt;/label&gt;&lt;br/&gt; &lt;input type=\"checkbox\" id=\"Coisini\" value=\"Coisini\" v-model=\"web_Names\"&gt; &lt;label for=\"Coisini\"&gt;Coisini&lt;/label&gt;&lt;!--这里的label for表示与id为多少的表单元素绑定--&gt;&lt;p&gt;{{web_Names}}&lt;/p&gt;&lt;/p&gt; 浏览器效果： Alt text 六、单选按钮绑定数据html代码： 123456&lt;h3&gt;单选按钮绑定&lt;/h3&gt;&lt;input type=\"radio\" id=\"one\" value=\"男\" v-model=\"sex\"&gt;&lt;label for=\"one\"&gt;男&lt;/label&gt;&lt;input type=\"radio\" id=\"two\" value=\"女\" v-model=\"sex\"&gt;&lt;label for=\"one\"&gt;女&lt;/label&gt;&lt;p&gt;{{sex}}&lt;/p&gt; js代码： 123456var app = new Vue({ el:'#app', data:{ sex:'男' }}) 浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第5节 v-0n：绑定事件监听器","date":"2020-03-13T12:36:04.000Z","path":"/posts/1d242cb0/","text":"Vue2.0 【第一季】 第5节 v-on：绑定事件监听器 第五节 v-on：绑定事件监听器v-on 就是监听事件，可以用v-on指令监听DOM事件来触发一些javascript代码。 一、使用绑定事件监听器，编写一个加分减分的程序。程序代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;v-on 实例&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-on 实例&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; 本场比赛得分：{{score}} &lt;p&gt; &lt;button v-on:click=\"add\"&gt;加分&lt;/button&gt; &lt;button v-on:click=\"subtract\"&gt;减分&lt;/button&gt;&lt;br/&gt; &lt;!-- 还有另一种写法：&lt;button @click=\"subtract\"&gt;减分&lt;/button&gt;&lt;br/&gt; --&gt; &lt;!-- 我们除了绑定click之外，我们还可以绑定其它事件，比如键盘回车事件v-on:keyup.enter,现在我们增加一个输入框，然后绑定回车事件，回车后把文本框里的值加到我们的count上。 绑定事件写法： --&gt; &lt;input type=\"text\" v-on:keyup.enter=\"onEnter\" v-model=\"score2\"&gt; &lt;!--这里绑定的是enter键，也可以写键值13，这样按enter键可以进行操作--&gt; &lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ score:0, score2:1 }, methods:{ add:function(){ this.score++; }, subtract:function(){ this.score--; }, onEnter:function(){ this.score=this.score + parseInt(this.score2); //js代码，因为文本框的数字会默认转变成字符串，所以我们需要用parseInt()函数进行整数转换。 } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 看一下浏览器效果： Alt text 附：键盘键值表： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第4节 v-text & v-html","date":"2020-03-13T12:35:22.000Z","path":"/posts/2db9414d/","text":"Vue2.0 【第一季】第4节 v-text &amp; v-html 第四节 v-text &amp; v-html我们已经会在html中输出data中的值了，我们已经用的是,这种情况是有弊端的，就是当我们网速很慢或者javascript出错时，会暴露我们的，容易引起XSS攻击。Vue给我们提供的v-text,就是解决这个问题的。我们来看代码： 1&lt;span&gt;{{ message }}&lt;/span&gt;=&lt;span v-text=\"message\"&gt;&lt;/span&gt;&lt;br/&gt; 完整代码是： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;v-text &amp; v-html&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-text &amp; v-html 实例&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;span&gt;{{ message }}&lt;/span&gt;=&lt;span v-text=\"message\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ message:'hello Vue!', } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 看一下浏览器效果： Alt text 但如果在javascript中写有html标签，用v-text是输出不出来的，这时候我们就需要用v-html标签了。 1&lt;span v-html=\"msgHtml\"&gt;&lt;/span&gt; 双大括号会将数据解释为纯文本，而非HTML。为了输出真正的HTML，你就需要使用v-html 指令。 需要注意的是：在生产环境中动态渲染HTML是非常危险的，因为容易导致XSS攻击。所以只能在可信的内容上使用v-html，永远不要在用户提交和可操作的网页上使用。 完整代码： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;v-text &amp; v-html&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-text &amp; v-html 实例&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;span&gt;{{ message }}&lt;/span&gt;=&lt;span v-text=\"message\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;span v-html=\"dodo\"&gt;&lt;/span&gt; &lt;!--此方式引起xss攻击--&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ message:'hello Vue!', dodo:'&lt;h2&gt;hello world!&lt;/h2&gt;' } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第3节 v-for指令：解决模板循环问题","date":"2020-03-13T12:34:37.000Z","path":"/posts/81cd718b/","text":"Vue2.0 【第一季】 第3节 v-for指令：解决模板循环问题 第三节 v-for 指令v-for指令是循环渲染一组data中的数组，v-for 指令需要以 item in items 形式的特殊语法，items 是源数据数组并且item是数组元素迭代的别名。 一、基本用法：模板写法 123&lt;li v-for=\"item in items\"&gt; {{item}}&lt;/li&gt; js写法： 123456var app = new Vue({ el:'#app', data:{ items:[20,23,18,65,32,19,54,56,41] }}) v-for.html完整写法： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;V-for 案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;v-for指令用法&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in items\"&gt; {{item}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ items:[20,23,18,65,32,19,54,56,41] } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是一个最基础的循环，先在js里定义了items数组，然后在模板中用v-for循环出来，需要注意的是，你需要哪个html标签循环，v-for就写在哪个上边。 浏览器效果： Alt text 二、排序我们已经顺利的输出了我们定义的数组，但是我需要在输出之前给数组排个序，那我们就用到了Vue的computed:属性。 12345computed:{ sortItems:function(){ return this.items.sort(); }} 我们在computed里新声明了一个对象sortItems，如果不重新声明会污染原来的数据源，这是Vue不允许的，所以你要重新声明一个对象。 相应的把： 123&lt;li v-for=\"item in items\"&gt; {{item}}&lt;/li&gt; 改成： 123&lt;li v-for=\"item in sortItems\"&gt; {{item}}&lt;/li&gt; 如果一切顺利的话，你已经看到了结果： Alt text 但是这个小程序还是有个小Bug的，现在我把数组修改成这样： items:[20,23,18,65,32,19,5,56,41] 我们把其中的54修改成了5，我们再看一下结果： Alt text 我们可以自己编写一个方法sortNumber，然后传给我们的sort函数解决这个Bug： 123function sortNumber(a,b){ return a-b} 如果不知道方法的位置，看一下完整的代码： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;V-for 案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;v-for指令用法&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in sortItems\"&gt; {{item}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ items:[20,23,18,65,32,19,5,56,41] }, computed:{ sortItems:function(){ return this.items.sort(sortNumber); } } }); function sortNumber(a,b){ return a-b } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 再次看一下浏览器效果： Alt text （这是重点，工作中常用。） 三、对象循环输出我们上边循环的都是数组，那我们来看一个对象类型的循环是如何输出的。我们先定义个数组，数组里边是对象数据： 123456students:[ {name:'Da0sy',age:21}, {name:'Daisy',age:19}, {name:'Coisini',age:20}, {name:'angelrain',age:18}] 在模板中输出： 12345&lt;ul&gt; &lt;li v-for=\"student in sortStudents\"&gt; {{student.name}} - {{student.age}} &lt;/li&gt;&lt;/ul&gt; 加入索引序号： 12345678//数组对象方法排序:function sortByKey(array,key){ return array.sort(function(a,b){ var x=a[key]; var y=b[key]; return ((x&lt;y)?-1:((x&gt;y)?1:0)); });} 有了数组的排序方法，在computed中进行调用排序 123sortStudents:function(){ return sortByKey(this.students,'age');} 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;v-for 实例&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;v-for 实例&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in sortItems\"&gt; {{item}} &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for=\"student in sortStudents\"&gt; {{student.name}}-{{student.age}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ items:[53,23,7,14,54,36,28], students:[ {name:'Da0sy',age:21}, {name:'Coisini',age:20}, {name:'Daisy',age:19}, {name:'angelrain',age:18} ] }, computed:{ sortItems:function(){ return this.items.sort(sortNumber); }, sortStudents:function(){ return sortByKey(this.students,'age'); } } }); function sortNumber(a,b){ return a-b; } //数组对象方法排序: function sortByKey(array,key){ return array.sort(function(a,b){ var x=a[key]; var y=b[key]; return ((x&lt;y)?-1:((x&gt;y)?1:0)); }); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 看一下浏览器效果： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第2节 v-if & v-else & v-show指令","date":"2020-03-13T12:28:30.000Z","path":"/posts/e38668cc/","text":"Vue2.0 【第一季】第2节 v-if v-else v-show 指令 第2节 v-if v-else v-show 指令2.1 v-if指令、v-else指令： 是vue的一个内部指令，用在html中。用来判断是否加载html的DOM，比如我们模拟一个用户登录状态，在用户登录后现实用户名称。 v-if.html代码：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;v-if &amp; v-show &amp; v-else&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;v-if 判断是否加载&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; &lt;div v-if=\"isLogin\"&gt;你好：Da0sy&lt;/div&gt; //关键代码 &lt;div v-else&gt;请登录后操作&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app=new Vue({ el:'#app', data:{ isLogin:true } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器效果： Alt text 这里我们在vue的data里定义了isLogin的值，当它为true时，网页就会显示：你好：Da0sy，如果为false时，就显示请登录后操作。 2.2 v-show的使用：调整css中display属性，DOM已经加载，只是CSS控制没有显示出来。 1&lt;div v-show=\"isLogin\"&gt;你好：Da0sy&lt;/div&gt; v-if 和v-show的区别： v-if：判断是否加载，可以减轻服务器的压力，在需要时加载。 v-show：调整css dispaly属性，可以使客户端操作更加流畅。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vue 2.0","slug":"vue-2-0","permalink":"http://tomotoes.com/tags/vue-2-0/"}]},{"title":"Vue2.0 【第一季】第1节 走进我的Vue2.0","date":"2020-03-12T07:55:26.000Z","path":"/posts/7ab8779e/","text":"Vue2.0 【第一季】内部指令记录一下我的代码地址：D:/Code/Vue编辑器：VS code 前置知识：1.HTML的基础知识，你需要达到中级水平，写前端页面的结构代码完全没有问题。2.CSS的基础知识，最好做过半年以上的切图和布局，最好了解CSS3的知识。3.Javascript的基础知识，对基本语法掌握，要求不高。4.node.js初级知识，只需要会npm的使用和项目初始化就可以了。（可不需） 第1节 走进我的Vue2.0 下载vue2.0的两个版本：https://cn.vuejs.org/ “学习” -&gt; \"教程\" -&gt; \"安装\" -&gt; \"开发版本和生产版本都下载\" 项目结构搭建 D盘新建文件夹Code，在Code里面新建文件夹Vue，将文件夹Vue拖进VS code； VS中的操作：（js中的两个文件直接从刚才下载的文件夹拖入） Alt text index.html 的内容: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue.js实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Vue2.0实例&lt;/h1&gt; &lt;hr&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=\"./example/helloworld.html\"&gt;Hello World实例&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 至此项目基本建完，需要安装live-server（VS终端）： cnpm install -g live-server 在项目目录中打开： live-server 可以看到浏览器启动的页面： Alt text 关掉ctrl+c终端服务，初始化一下前端效果： cnpm initname：vue 小写字母就行description：Vue Demoentry point：回车即可，这里不改test command：回车git repository：回车，有git库就写keywords：回车，可不写author：Cardiac（写自己的） 建完以后，在Vue中就生成package.json文件（方便以后进行包的管理）： Alt text 可以进行第一个文件的编写，在example文件夹下新建helloworld.html helloworld.html 的内容: 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;HelloWorld&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../assets/js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;hr&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = new Vue({ el:'#app', data:{ message:'hello Vue!' } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 启动服务器live-server，就可看到页面，点击Hello World实例链接： Alt text document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Vue 2.0","slug":"Vue-2-0","permalink":"http://tomotoes.com/tags/Vue-2-0/"}]},{"title":"初学Git","date":"2020-03-12T02:12:21.000Z","path":"/posts/a8d530d8/","text":"我的练习地址：D: \\learngit\\node.txt Git的诞生 Git是用C语言开发的； Git是分布式版本控制系统：没有“中央服务器”、不需要联网、安全性高很多（每个人电脑里都有完整的版本库）； Git有极其强大的分支管理。 安装Git后创建版本库（又名仓库，repository）选择一个合适的地方，创建一个空目录： $ cd D:/ // 切换盘符，我这里进入D盘 $ cd .. // 回到文件上一层(注: cd与..中间有个空格) $ cd ~ // 回到当前目录的主目录 $ mkdir Git // 创建文件夹Git $ touch fileName // 新建文件 $ vi fileName // 编辑文件 $ press i button // 开始进入编辑状态 $ press the Esc button // 退出vim编辑区（一直按住ESC，按两次大写的Z；或者按ESC键然后输入::q!即可不保存退出） $ :wq // 退出编辑状态, 回到命令窗口（这是保存退出） $ mkdir learngit // 创建文件夹learngit（我的在D盘中创建） $ pwd // 显示当前路径/e/Git/learngit $ git init // 将当前目录变成一个Git可以管理的仓库 $ touch+文件名 // 直接新建一个文件（node.txt） $ git add node.txt // 将文件node.txt添加到Git仓库（把文件修改添加到暂存区） $ git commit -m “wrote a node.txt.” // 将文件提交到仓库（把暂存区的所有内容提交到当前分支）,命令执行成功会告诉你1 file changed: 1个文件被改动（我们新添加的node.txt文件）；2 insertions: 插入了两行内容（node.txt有两行内容）。 $ git add file1.txt // 添加file1.txt文件 $ git add file2.txt file3.txt // 同时添加file2.txt和file3.txt两个文件（可多次） $ git commit -m “add 3 files.” // 一次性提交3个文件（commit可以一次提交很多文件） 时光机穿梭 2.1 版本回退 $ git status // 查看当前仓库状态（仓库下的工作区文件是否被修改过） $ git diff readme.txt // 查看工作区的node.txt与缓存区的node.txt的区别 $ git log // 查看最近到最远的提交记录（详情: commit id + Author + Date + comment） $ git log –pretty=oneline // 如果嫌输出信息太多，可以试试查看最近到最远的提交记录（简写：commit id + comment）。看到的一大串类似10c7e…的是commit id(版本号) $ git reset –hard HEAD^ // 回到上一个版本（HEAD: 当前版本，HEAD^: 上一个版本，HEAD^^: 上上一个版本，HEAD~100: 往上100个版本） $ git reset –hard 1234567 // 回到指定版本号commit id（此处：commit id 假设为1234567**，版本号不需要写全，Git会根据commit id的前几位自动寻找对应的版本） $ cat readme.txt // 查看readme.txt的内容 $ git reflog // 查看每一次命令记录历史，确保能回到任意版本 2.2 工作区与暂存区 $ git diff readme.txt // 比较工作区（working directory）和暂存区（stage/index）的区别；工作区即电脑里能看到的目录，例如learngit文件夹。 版本库：工作区有一个隐藏目录.git，这个不算是工作区，而是Git的版本库。Git的版本库里存了很多东西，最重要的就是stage（或叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 Alt text 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 $ git diff –cached // 比较暂存区（stage/index）和分支（master）的区别 2.3 管理修改（详见1. 创建版本库中的命令） 2.4 撤销修改 $ git checkout – node.txt // 撤销修改：1. 文件在添加到缓存区前修改，则回退到原工作区状态；2. 文件在添加到缓存区后修改，则回退到原缓存区状态。也即是将node.txt撤回到最近一次git add或git commit状态（注：–表示在当前分支，如果没有，则切换到另一个分支） $ cat node.txt // 查看文件内容 $ git reset HEAD node.txt // 1. 回退到最新版本；2. 将暂存区的修改回退到工作区 2.5 删除文件 $ rm test.txt // 删除工作区文件（类似于手动删除） $ git status // 查看当前工作区与缓存区状态 $ git rm test.txt // 情况1：确认删除 $ git commit -m “remove test.txt” // 情况1：确认删除后，提交到版本库 $ git checkout – test.txt // 情况2：误删，需要回退（即：用版本库里的版本替换工作区的版本） 远程仓库注册GitHub账号（因为你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要创建SSH kEY）: 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa(私钥，不能泄露）和id_rsa.pub（公钥）这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C “youremail@example.com“ 把邮件地址换成自己的邮件地址，一路回车，使用默认值即可。 登录GitHub，打开“Account settings”，“SSH Keys”页面；然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容；点“Add Key”，你就应该看到已经添加的Key，这样就在本地创建了一个Git仓库，要想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。 首先，登陆GitHub，点击右上角“Create a new repo”按钮，创建一个新的仓库；在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库；目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 3.1 添加远程库$ git remote add origin git@server-name:path/repo-name.git// 关联一个远程仓库，如： git remote add origin git@github.com:GitHub用户名/learngit.git // 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上：git push -u origin master // 第一次推送master分支的所有内容注：在GitHub上创建新仓库时，如果勾选了README.md选项时，可能会出现下面错误，提示：远程仓库有readme.txt,而本地仓库没有README.txt,此时应该先进行合并文件，再进行推送。 $ git pull –rebase origin master // 推送之前，进行合并 合并文件之后，发现本地仓库中多了README.md文件，此时再进行推送修改到远程仓库就可以了。 再次执行：git push -u origin master, 即可推送本地仓库到远程仓库了 $ git push origin master // 以后每次本地修改更新后，推送最新修改 3.2 从远程库克隆假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆GitHub，创建一个新的仓库，名字叫gitskills，勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： Alt text $ git clone git@github.com:Da0sy/gitskills.git // 以SSH方式克隆一个本地库，默认的git://使用ssh，但也可使用https等协议，看以下这种方式： $ git clone https://github.com/Da0sy/gitskills.git // 以Https协议方式克隆然后进入gitskills目录看，已经有README.md文件了。但这种方式没有上一种快。 分支管理在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即 master 分支。 HEAD 严格来说不是指向提交，而是指向 master ， master 才是指向提交的，所以， HEAD 指向的就是当前分支。 一开始的时候， master 分支是一条线， Git 用 master 指向最新的提交，再用 HEAD 指向 master ，就能确定当前分支，以及当前分支的提交点： Alt text 每次提交， master 分支都会向前移动一步，这样，随着你不断提交， master 分支的线也越来越长。 当我们创建新的分支，例如 dev 时， Git 新建了一个指针叫 dev ，指向 master 相同的提交，再把 HEAD 指向 dev ，就表示当前分支在 dev 上： Alt text Git 创建一个分支很快，除了增加一个 dev 指针，改改 HEAD 的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后， dev 指针往前移动一步，而 master 指针不变： Alt text 假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。 Git 怎么合并呢？最简单的方法，就是直接把 master 指向 dev 的当前提交，就完成了合并： Alt text 合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把 dev 指针给删掉，删掉后，我们就剩下了一条 master 分支： Alt text 4.1 创建与合并分支 git branch // 查看所有分支（当前分支以‘*’标记） git branch name // 创建分支（如：git branch dev） git checkout name 或者git switch name// 切换分支 git checkout -b name 或者git switch -c name// 创建切换分支（如：git checkout -b dev） git merge name // 合并分支(name)到当前分支上 git branch -d name // 删除该分支 4.2 解决冲突 git log –graph // 查看分支合并图 git log –graph –pretty=oneline –abbrev-commit // 查看分支合并缩略图 4.3 分支管理策略 git merge –no-ff -m “注释” dev // 合并后的分支有历史记录，而Fast-Forward合并之后，分支没有历史记录 4.4 Bug分支 git stash // 隐藏分支工作现场，为修复bug准备 git stash list // 查看有哪些分支隐藏的工作现场，为恢复工作现场做准备 git stash apply // 恢复工作现场，但不删除存储的stash内容，结合git stash drop进行删除 git stash drop // 删除存储的stash内容，恢复到隐藏前的工作现场 git stash pop // 恢复到隐藏前的工作现场，相当于git stash apply和git stash drop git stash apply stash@{0} // 可以多次stash，通过git stash list查看所有的stash，然后可以恢复到指定的隐藏的工作现场 4.5 Feature分支 注：当添加一个feature时，最好新建一个分支：git checkout -b name git branch -D name // 强行删除一个没有被合并到主分支的分支 4.6 多人协作（最好结合工作场景理解） git remote -v // 查看远程库详细信息 git push origin dev // push本地dev分支到远程dev git push origin master // push本地master分支到远程master（时刻保持同步） git pull // 将最新的pull/dev(master)爬下来 git checkout -b branch-name origin/branch-name // 在本地创建和远程分支对应的分支 git branch –set-upstream-to=origin/branch-name dev // 建立本地分支和远程分支的关联 4.7 Rebase git rebase // 将本地未push的分支提交整理成直线，利于查看 标签管理 git tag tagname // 创建标签 git tag // 查看所有标签 git tag tagname commitId // 为某次提交创建指定标签 git show tagname // 查看指定标签具体内容 git tag -a tagname -m “v0.1 released” commitId // 为某次指定的提交创建标签，同时添加标签注释 git tag -d tagname // 删除某个标签 git push origin tagname // 推送某个标签到远程库 git push origin –tags // 一次性推送所有标签到远程库 git tag -d v0.9 // 删除远程库标签（第一步：删除本地库标签） git push origin :refs/tags/v0.9 // 删除远程库标签（第二步：从远程库删除标签） 使用GitHub 在GitHub上，可以自己fork任意开源仓库，自己拥有fork后的仓库的读与写操作权限，可以推送pull request给官方仓库贡献代码。 使用码云（与GitHub类似，用到的时候，再注册使用练习，毕竟GitHub更加NB一些！）自定义Git（这里只是简单入门） git config –global color.ui true // 让Git显示颜色 8.1 忽略特殊文件 忽略某些文件时，需要编写.gitignore文件，文件本身要放到版本库中，Git可以对.gitignore做版本管理！（注：不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore） 8.2 配置别名 git config –global alias.st status // 将st作为status的别名，以后就可以git st查看暂存区与工作区的状态了（还有类似co:checkout, ci:commit, br:branch，–global:是针对于当前用户起作用的，如果不加，则只针对于当前仓库） cat .gitignore // 查看当前文件所有配置信息（包括别名信息） 8.3 搭建Git服务器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Git","slug":"Git","permalink":"http://tomotoes.com/tags/Git/"}]}]